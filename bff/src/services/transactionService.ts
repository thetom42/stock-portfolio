import { CreateTransactionDTO, Transaction as BFFTransaction, TransactionQueryParams, PaginatedTransactions } from '../models/Transaction';
import { Transaction as DBTransaction } from '../../../db/models/Transaction';
import { getPrismaClient } from '../utils/database';
import { TransactionRepository } from '../../../db/repositories/TransactionRepository';
import { HoldingRepository } from '../../../db/repositories/HoldingRepository';
import { PortfolioRepository } from '../../../db/repositories/PortfolioRepository';
import { Decimal } from '@prisma/client/runtime/library';

// Initialize repositories with default implementations
const prisma = getPrismaClient();
let transactionRepository = new TransactionRepository(prisma);
let holdingRepository = new HoldingRepository(prisma);
let portfolioRepository = new PortfolioRepository(prisma);

// For testing: allow repository injection
export const setTransactionRepository = (repo: any) => {
    transactionRepository = repo;
};

export const setHoldingRepository = (repo: any) => {
    holdingRepository = repo;
};

export const setPortfolioRepository = (repo: any) => {
    portfolioRepository = repo;
};

// Helper function to map DB Transaction to BFF Transaction
const mapDBTransactionToBFF = (dbTransaction: DBTransaction): BFFTransaction => ({
    id: dbTransaction.transaction_id,
    holding_id: dbTransaction.holding_id,
    buy: dbTransaction.buy,
    transaction_time: dbTransaction.transaction_time,
    amount: dbTransaction.amount,
    price: Number(dbTransaction.price),
    commission: Number(dbTransaction.commission),
    broker: dbTransaction.broker
});

// Helper function to map array of DB Transactions to BFF Transactions
const mapDBTransactionsToBFF = (dbTransactions: DBTransaction[]): BFFTransaction[] => 
    dbTransactions.map(mapDBTransactionToBFF);

// Helper function to filter and sort transactions
const filterAndSortTransactions = (
    transactions: BFFTransaction[],
    params: TransactionQueryParams
): BFFTransaction[] => {
    let filtered = [...transactions];

    // Apply date filters
    if (params.startDate) {
        const startDate = new Date(params.startDate);
        filtered = filtered.filter(t => t.transaction_time >= startDate);
    }
    if (params.endDate) {
        const endDate = new Date(params.endDate);
        filtered = filtered.filter(t => t.transaction_time <= endDate);
    }

    // Apply type filter
    if (params.type) {
        filtered = filtered.filter(t => t.buy === (params.type === 'BUY'));
    }

    // Apply sorting
    if (params.sort) {
        filtered.sort((a, b) => {
            const order = params.order === 'desc' ? -1 : 1;
            switch (params.sort) {
                case 'date':
                    return order * (a.transaction_time.getTime() - b.transaction_time.getTime());
                case 'amount':
                    return order * (a.amount - b.amount);
                case 'price':
                    return order * (a.price - b.price);
                default:
                    return 0;
            }
        });
    }

    return filtered;
};

// Helper function to paginate transactions
const paginateTransactions = (
    transactions: BFFTransaction[],
    page: number = 1,
    limit: number = 10
): PaginatedTransactions => {
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedTransactions = transactions.slice(startIndex, endIndex);
    const total = transactions.length;
    const totalPages = Math.ceil(total / limit);

    return {
        transactions: paginatedTransactions,
        total,
        page,
        limit,
        totalPages
    };
};

export const createTransaction = async (
    userId: string,
    holdingId: string,
    transactionData: CreateTransactionDTO
): Promise<BFFTransaction> => {
    // Verify holding ownership through portfolio
    const holding = await holdingRepository.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    const portfolio = await portfolioRepository.findById(holding.portfolio_id);
    
    if (!portfolio || portfolio.user_id !== userId) {
        throw new Error('Unauthorized');
    }

    // Calculate new quantity before creating transaction
    const newQuantity = transactionData.buy
        ? holding.quantity + transactionData.amount
        : holding.quantity - transactionData.amount;

    if (newQuantity < 0) {
        throw new Error('Insufficient holding quantity for sell transaction');
    }

    // Create the transaction
    const transaction = await transactionRepository.create({
        transaction_id: '', // Will be generated by the repository
        holding_id: holdingId,
        buy: transactionData.buy,
        transaction_time: new Date(),
        amount: transactionData.amount,
        price: new Decimal(transactionData.price),
        commission: new Decimal(transactionData.commission || 0),
        broker: transactionData.broker || 'SYSTEM'
    });

    // Update holding quantity
    await holdingRepository.update(holdingId, { quantity: newQuantity });

    return mapDBTransactionToBFF(transaction);
};

export const getTransactionById = async (
    userId: string,
    transactionId: string
): Promise<BFFTransaction> => {
    const transaction = await transactionRepository.findById(transactionId);

    if (!transaction) {
        throw new Error('Transaction not found');
    }

    // Verify ownership through holding and portfolio
    const holding = await holdingRepository.findById(transaction.holding_id);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    const portfolio = await portfolioRepository.findById(holding.portfolio_id);
    
    if (!portfolio || portfolio.user_id !== userId) {
        throw new Error('Unauthorized');
    }

    return mapDBTransactionToBFF(transaction);
};

export const getTransactionsByHolding = async (
    userId: string,
    holdingId: string,
    queryParams: TransactionQueryParams = {}
): Promise<PaginatedTransactions> => {
    // Verify holding ownership
    const holding = await holdingRepository.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    const portfolio = await portfolioRepository.findById(holding.portfolio_id);
    
    if (!portfolio || portfolio.user_id !== userId) {
        throw new Error('Unauthorized');
    }

    // Get transactions
    const transactions = await transactionRepository.findByHoldingId(holdingId);
    const bffTransactions = mapDBTransactionsToBFF(transactions);
    
    // Apply filters and sorting
    const filteredTransactions = filterAndSortTransactions(bffTransactions, queryParams);
    
    // Apply pagination
    return paginateTransactions(
        filteredTransactions,
        queryParams.page,
        queryParams.limit
    );
};

export const getTransactionsByPortfolio = async (
    userId: string,
    portfolioId: string,
    queryParams: TransactionQueryParams = {}
): Promise<PaginatedTransactions> => {
    // Verify portfolio ownership
    const portfolio = await portfolioRepository.findById(portfolioId);
    
    if (!portfolio || portfolio.user_id !== userId) {
        throw new Error('Unauthorized');
    }

    // Get holdings for the portfolio
    const holdings = await holdingRepository.findByPortfolioId(portfolioId);

    // Get transactions for all holdings
    const transactionPromises = holdings.map(holding => 
        transactionRepository.findByHoldingId(holding.holding_id)
    );
    
    const transactionArrays = await Promise.all(transactionPromises);
    const transactions = transactionArrays.flat();
    const bffTransactions = mapDBTransactionsToBFF(transactions);

    // Apply filters and sorting
    const filteredTransactions = filterAndSortTransactions(bffTransactions, queryParams);
    
    // Apply pagination
    return paginateTransactions(
        filteredTransactions,
        queryParams.page,
        queryParams.limit
    );
};
