import { CreateTransactionDTO, Transaction as BFFTransaction, TransactionQueryParams, PaginatedTransactions } from '../models/Transaction';
import { Transaction as DBTransaction } from '../../../db/models/Transaction';
import { getPrismaClient } from '../utils/database';
import { TransactionRepository } from '../../../db/repositories/TransactionRepository';
import { HoldingRepository } from '../../../db/repositories/HoldingRepository';
import { PortfolioRepository } from '../../../db/repositories/PortfolioRepository';
import { Decimal } from '@prisma/client/runtime/library';

// Initialize repositories with default implementations
const prisma = getPrismaClient();
let transactionRepository = new TransactionRepository(prisma);
let holdingRepository = new HoldingRepository(prisma);
let portfolioRepository = new PortfolioRepository(prisma);

// For testing: allow repository injection
export const setTransactionRepository = (repo: any) => {
    transactionRepository = repo;
};

export const setHoldingRepository = (repo: any) => {
    holdingRepository = repo;
};

export const setPortfolioRepository = (repo: any) => {
    portfolioRepository = repo;
};

// Helper function to map DB Transaction to BFF Transaction
const mapDBTransactionToBFF = (dbTransaction: DBTransaction): BFFTransaction => ({
    ...dbTransaction,
    PRICE: Number(dbTransaction.PRICE),
    COMMISSION: Number(dbTransaction.COMMISSION)
});

// Helper function to map array of DB Transactions to BFF Transactions
const mapDBTransactionsToBFF = (dbTransactions: DBTransaction[]): BFFTransaction[] => 
    dbTransactions.map(mapDBTransactionToBFF);

// Helper function to filter and sort transactions
const filterAndSortTransactions = (
    transactions: BFFTransaction[],
    params: TransactionQueryParams
): BFFTransaction[] => {
    let filtered = [...transactions];

    // Apply date filters
    if (params.startDate) {
        const startDate = new Date(params.startDate);
        filtered = filtered.filter(t => t.TRANSACTION_TIME >= startDate);
    }
    if (params.endDate) {
        const endDate = new Date(params.endDate);
        filtered = filtered.filter(t => t.TRANSACTION_TIME <= endDate);
    }

    // Apply type filter
    if (params.type) {
        filtered = filtered.filter(t => t.BUY === (params.type === 'BUY'));
    }

    // Apply sorting
    if (params.sort) {
        filtered.sort((a, b) => {
            const order = params.order === 'desc' ? -1 : 1;
            switch (params.sort) {
                case 'date':
                    return order * (a.TRANSACTION_TIME.getTime() - b.TRANSACTION_TIME.getTime());
                case 'amount':
                    return order * (a.AMOUNT - b.AMOUNT);
                case 'price':
                    return order * (a.PRICE - b.PRICE);
                default:
                    return 0;
            }
        });
    }

    return filtered;
};

// Helper function to paginate transactions
const paginateTransactions = (
    transactions: BFFTransaction[],
    page: number = 1,
    limit: number = 10
): PaginatedTransactions => {
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedTransactions = transactions.slice(startIndex, endIndex);
    const total = transactions.length;
    const totalPages = Math.ceil(total / limit);

    return {
        transactions: paginatedTransactions,
        total,
        page,
        limit,
        totalPages
    };
};

export const createTransaction = async (
    userId: string,
    holdingId: string,
    transactionData: CreateTransactionDTO
): Promise<BFFTransaction> => {
    // Verify holding ownership through portfolio
    const holding = await holdingRepository.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    const portfolio = await portfolioRepository.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Calculate new quantity before creating transaction
    const newQuantity = transactionData.BUY
        ? holding.QUANTITY + transactionData.AMOUNT
        : holding.QUANTITY - transactionData.AMOUNT;

    if (newQuantity < 0) {
        throw new Error('Insufficient holding quantity for sell transaction');
    }

    // Create the transaction
    const transaction = await transactionRepository.create({
        TRANSACTIONS_ID: '', // Will be generated by the repository
        HOLDINGS_ID: holdingId,
        BUY: transactionData.BUY,
        TRANSACTION_TIME: new Date(),
        AMOUNT: transactionData.AMOUNT,
        PRICE: new Decimal(transactionData.PRICE),
        COMMISSION: new Decimal(transactionData.COMMISSION || 0),
        BROKER: transactionData.BROKER || 'SYSTEM'
    });

    // Update holding quantity
    await holdingRepository.update(holdingId, { QUANTITY: newQuantity });

    return mapDBTransactionToBFF(transaction);
};

export const getTransactionById = async (
    userId: string,
    transactionId: string
): Promise<BFFTransaction> => {
    const transaction = await transactionRepository.findById(transactionId);

    if (!transaction) {
        throw new Error('Transaction not found');
    }

    // Verify ownership through holding and portfolio
    const holding = await holdingRepository.findById(transaction.HOLDINGS_ID);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    const portfolio = await portfolioRepository.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    return mapDBTransactionToBFF(transaction);
};

export const getTransactionsByHolding = async (
    userId: string,
    holdingId: string,
    queryParams: TransactionQueryParams = {}
): Promise<PaginatedTransactions> => {
    // Verify holding ownership
    const holding = await holdingRepository.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    const portfolio = await portfolioRepository.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Get transactions
    const transactions = await transactionRepository.findByHolding(holdingId);
    const bffTransactions = mapDBTransactionsToBFF(transactions);
    
    // Apply filters and sorting
    const filteredTransactions = filterAndSortTransactions(bffTransactions, queryParams);
    
    // Apply pagination
    return paginateTransactions(
        filteredTransactions,
        queryParams.page,
        queryParams.limit
    );
};

export const getTransactionsByPortfolio = async (
    userId: string,
    portfolioId: string,
    queryParams: TransactionQueryParams = {}
): Promise<PaginatedTransactions> => {
    // Verify portfolio ownership
    const portfolio = await portfolioRepository.findById(portfolioId);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Get holdings for the portfolio
    const holdings = await holdingRepository.findByPortfolio(portfolioId);

    // Get transactions for all holdings
    const transactionPromises = holdings.map(holding => 
        transactionRepository.findByHolding(holding.HOLDINGS_ID)
    );
    
    const transactionArrays = await Promise.all(transactionPromises);
    const transactions = transactionArrays.flat();
    const bffTransactions = mapDBTransactionsToBFF(transactions);

    // Apply filters and sorting
    const filteredTransactions = filterAndSortTransactions(bffTransactions, queryParams);
    
    // Apply pagination
    return paginateTransactions(
        filteredTransactions,
        queryParams.page,
        queryParams.limit
    );
};
