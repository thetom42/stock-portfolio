import { Quote, HistoricalQuote, QuoteInterval, RealTimeQuote, QuoteHistory } from '../models/Quote';
import { getYahooFinanceService } from './yahooFinanceService';
import { getPrismaClient } from '../utils/database';
import { QuoteRepository, StockRepository } from '@stock-portfolio/db';
import type { Quote as DBQuote } from '@stock-portfolio/db/dist/models/Quote';
import type { Stock as DBStock } from '@stock-portfolio/db/dist/models/Stock';
import { Decimal } from '@prisma/client/runtime/library';

export class QuoteService {
  private quoteRepository: QuoteRepository;
  private stockRepository: StockRepository;

  constructor(quoteRepo?: QuoteRepository, stockRepo?: StockRepository) {
    const prisma = getPrismaClient();
    this.quoteRepository = quoteRepo || new QuoteRepository(prisma);
    this.stockRepository = stockRepo || new StockRepository(prisma);
  }

  // Helper function to map DB Quote to BFF Quote
  private mapDBQuoteToBFF = (dbQuote: DBQuote): Quote => ({
    id: dbQuote.quote_id,
    stockId: dbQuote.isin,
    price: Number(dbQuote.price),
    currency: dbQuote.currency,
    timestamp: dbQuote.market_time
  });

  // Check if a quote is stale (older than 15 minutes)
  private isQuoteStale = (quote: DBQuote | null): boolean => {
    if (!quote) return true;
    const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);
    return new Date(quote.market_time) < fifteenMinutesAgo;
  };

  // Get real-time quote for a stock
  async getRealTimeQuote(stockId: string): Promise<RealTimeQuote> {
    try {
      const stock = await this.stockRepository.findByIsin(stockId);
      if (!stock) {
        throw new Error('Stock not found');
      }

      // Check for cached quote
      const cachedQuote = await this.quoteRepository.findLatestByIsin(stock.isin);
      if (cachedQuote && !this.isQuoteStale(cachedQuote)) {
        // Use cached quote if it exists and is not stale
        return {
          price: Number(cachedQuote.price),
          change: 0, // We don't calculate change for cached quotes
          changePercent: 0,
          timestamp: cachedQuote.market_time
        };
      }

      // If no valid cached quote, fetch from Yahoo Finance
      const yahooFinance = getYahooFinanceService();
      const quote = await yahooFinance.getRealTimeQuote(stock.isin);

      // Store the quote in our database
      await this.quoteRepository.create({
        quote_id: '', // Will be ignored/auto-generated by Prisma
        isin: stock.isin,
        price: new Decimal(quote.price),
        currency: quote.currency,
        market_time: new Date(quote.timestamp),
        exchange: quote.exchange
      });

      // Get previous quote for price change calculation
      const prevQuote = await this.quoteRepository.findLatestByIsin(stock.isin);
      const previousPrice = prevQuote ? Number(prevQuote.price) : quote.price;
      const change = quote.price - previousPrice;
      const changePercent = (change / previousPrice) * 100;

      return {
        price: quote.price,
        change,
        changePercent,
        timestamp: new Date(quote.timestamp)
      };
    } catch (error) {
      if (error instanceof Error && error.message === 'Stock not found') {
        throw error;
      }
      throw new Error('Failed to fetch quote data');
    }
  }

  // Get historical quotes for a stock
  async getHistoricalQuotes(stockId: string, interval: QuoteInterval): Promise<QuoteHistory> {
    try {
      const stock = await this.stockRepository.findByIsin(stockId);
      if (!stock) {
        throw new Error('Stock not found');
      }

      const yahooFinance = getYahooFinanceService();
      const yahooQuotes = await yahooFinance.getHistoricalQuotes(stock.isin, {
        interval: interval.interval,
        range: interval.range
      });

      // Map Yahoo Finance quotes to our model structure and store in database
      const quotes: HistoricalQuote[] = await Promise.all(
        yahooQuotes.map(async (yq) => {
          // Store only the closing price in our database
          await this.quoteRepository.create({
            quote_id: '', // Will be ignored/auto-generated by Prisma
            isin: stock.isin,
            price: new Decimal(yq.close),
            currency: 'USD', // Yahoo Finance default
            market_time: yq.date,
            exchange: 'YAHOO'
          });

          // Return the full historical quote data without storing extra fields
          return {
            date: yq.date,
            open: yq.open,
            high: yq.high,
            low: yq.low,
            close: yq.close,
            adjustedClose: yq.adjClose,
            volume: yq.volume
          };
        })
      );

      return {
        symbol: stock.symbol,
        interval: interval.interval,
        quotes
      };
    } catch (error) {
      if (error instanceof Error && error.message === 'Stock not found') {
        throw error;
      }
      throw new Error('Failed to fetch historical data');
    }
  }

  // Get latest quotes for multiple stocks
  async getLatestQuotes(stockIds: string[]): Promise<Quote[]> {
    if (stockIds.length === 0) {
      return [];
    }

    const quotes: Quote[] = [];

    for (const stockId of stockIds) {
      const quote = await this.quoteRepository.findLatestByIsin(stockId);
      if (quote) {
        quotes.push(this.mapDBQuoteToBFF(quote));
      }
    }

    return quotes;
  }

  // Get quote history from database
  async getQuoteHistory(stockId: string, startDate: Date, endDate: Date): Promise<Quote[]> {
    // Since findByStockAndTimeRange is not available, we'll get all quotes and filter
    const quotes = await this.quoteRepository.findByIsin(stockId);
    const filteredQuotes = quotes.filter(quote => {
      const quoteDate = new Date(quote.market_time);
      return quoteDate >= startDate && quoteDate <= endDate;
    });
    return filteredQuotes.map(this.mapDBQuoteToBFF);
  }

  // Get intraday quotes
  async getIntradayQuotes(stockId: string): Promise<Quote[]> {
    try {
      const stock = await this.stockRepository.findByIsin(stockId);
      if (!stock) {
        throw new Error('Stock not found');
      }

      const yahooFinance = getYahooFinanceService();
      const yahooQuotes = await yahooFinance.getIntradayQuotes(stock.isin);

      // Store intraday quotes in database and return them
      const dbQuotes = await Promise.all(
        yahooQuotes.map(async (yq) => {
          const quote = await this.quoteRepository.create({
            quote_id: '', // Will be ignored/auto-generated by Prisma
            isin: stock.isin,
            price: new Decimal(yq.price),
            currency: 'USD', // Yahoo Finance default
            market_time: new Date(yq.timestamp),
            exchange: 'YAHOO'
          });
          return quote;
        })
      );

      return dbQuotes.map(this.mapDBQuoteToBFF);
    } catch (error) {
      if (error instanceof Error && error.message === 'Stock not found') {
        throw error;
      }
      throw new Error('Failed to fetch intraday data');
    }
  }
}

// Export a singleton instance
export const quoteService = new QuoteService();

// For testing: allow repository injection
export const setQuoteRepository = (repo: QuoteRepository) => {
  return new QuoteService(repo);
};

export const setStockRepository = (repo: StockRepository) => {
  return new QuoteService(undefined, repo);
};
