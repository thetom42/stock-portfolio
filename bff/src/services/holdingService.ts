import { Holding, CreateHoldingDTO, UpdateHoldingDTO, HoldingDetails, HoldingPerformance, HoldingValue, HoldingHistory } from '../models/Holding';
import { Transaction } from '../models/Transaction';
import { Stock } from '../models/Stock';
import { getHoldingRepository, getPortfolioRepository, getTransactionRepository, getStockRepository } from '../utils/database';
import * as quoteService from './quoteService';
import { Decimal } from '@prisma/client/runtime/library';

// Helper type for holding with stock information
interface HoldingWithStock extends Holding {
    stockInfo: {
        symbol: string;
        name: string;
        isin: string;
    };
}

const calculateHoldingValue = async (
    holding: HoldingWithStock
): Promise<HoldingValue> => {
    const transactionRepo = getTransactionRepository();
    const transactions = await transactionRepo.findByHolding(holding.HOLDINGS_ID);
    
    let totalCost = new Decimal(0);
    let totalQuantity = new Decimal(0);
    
    transactions.forEach(t => {
        if (t.BUY) {
            totalCost = totalCost.add(t.PRICE.mul(t.AMOUNT));
            totalQuantity = totalQuantity.add(t.AMOUNT);
        } else {
            const avgCost = totalCost.div(totalQuantity);
            totalCost = totalCost.sub(avgCost.mul(t.AMOUNT));
            totalQuantity = totalQuantity.sub(t.AMOUNT);
        }
    });

    const quote = await quoteService.getRealTimeQuote(holding.stockInfo.isin);
    const averageCost = totalQuantity.equals(0) ? new Decimal(0) : totalCost.div(totalQuantity);
    const currentValue = new Decimal(quote.price).mul(holding.QUANTITY);
    const unrealizedGainLoss = currentValue.sub(averageCost.mul(holding.QUANTITY));

    return {
        quantity: holding.QUANTITY,
        costBasis: Number(totalCost),
        averageCost: Number(averageCost),
        currentValue: Number(currentValue),
        unrealizedGainLoss: Number(unrealizedGainLoss)
    };
};

export const createHolding = async (
    userId: string,
    createHoldingDTO: CreateHoldingDTO
): Promise<HoldingDetails> => {
    // Verify portfolio ownership
    const portfolioRepo = getPortfolioRepository();
    const portfolio = await portfolioRepo.findById(createHoldingDTO.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Verify stock exists
    const stockRepo = getStockRepository();
    const dbStock = await stockRepo.findByISIN(createHoldingDTO.ISIN);
    
    if (!dbStock) {
        throw new Error('Stock not found');
    }

    // Create holding
    const holdingRepo = getHoldingRepository();
    const holding = await holdingRepo.create({
        HOLDINGS_ID: '', // Will be generated by the repository
        PORTFOLIOS_ID: createHoldingDTO.PORTFOLIOS_ID,
        ISIN: createHoldingDTO.ISIN,
        QUANTITY: createHoldingDTO.QUANTITY,
        START_DATE: new Date(),
        END_DATE: null
    });

    // Create initial buy transaction
    const transactionRepo = getTransactionRepository();
    await transactionRepo.create({
        TRANSACTIONS_ID: '', // Will be generated by the repository
        HOLDINGS_ID: holding.HOLDINGS_ID,
        BUY: true,
        TRANSACTION_TIME: new Date(),
        AMOUNT: createHoldingDTO.QUANTITY,
        PRICE: new Decimal(createHoldingDTO.PRICE),
        COMMISSION: new Decimal(0),
        BROKER: 'SYSTEM'
    });

    // Get current price
    const quote = await quoteService.getRealTimeQuote(dbStock.ISIN);
    const totalValue = quote.price * holding.QUANTITY;
    const gainLoss = totalValue - (createHoldingDTO.PRICE * holding.QUANTITY);
    const gainLossPercentage = (gainLoss / (createHoldingDTO.PRICE * holding.QUANTITY)) * 100;

    return {
        ...holding,
        stock: {
            symbol: dbStock.SYMBOL.toLowerCase(),
            name: dbStock.NAME,
            currency: 'USD' // Default currency since it's not in DB model
        },
        currentPrice: quote.price,
        totalValue,
        gainLoss,
        gainLossPercentage
    };
};

export const getHoldingById = async (
    userId: string,
    holdingId: string
): Promise<HoldingDetails> => {
    const holdingRepo = getHoldingRepository();
    const holding = await holdingRepo.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    // Verify ownership through portfolio
    const portfolioRepo = getPortfolioRepository();
    const portfolio = await portfolioRepo.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Get stock details
    const stockRepo = getStockRepository();
    const dbStock = await stockRepo.findByISIN(holding.ISIN);
    
    if (!dbStock) {
        throw new Error('Stock not found');
    }

    const holdingWithStock: HoldingWithStock = {
        ...holding,
        stockInfo: {
            symbol: dbStock.SYMBOL.toLowerCase(),
            name: dbStock.NAME,
            isin: dbStock.ISIN
        }
    };

    // Get current price and calculate values
    const quote = await quoteService.getRealTimeQuote(dbStock.ISIN);
    const holdingValue = await calculateHoldingValue(holdingWithStock);

    return {
        ...holding,
        stock: {
            symbol: dbStock.SYMBOL.toLowerCase(),
            name: dbStock.NAME,
            currency: 'USD' // Default currency since it's not in DB model
        },
        currentPrice: quote.price,
        totalValue: holdingValue.currentValue,
        gainLoss: holdingValue.unrealizedGainLoss,
        gainLossPercentage: (holdingValue.unrealizedGainLoss / holdingValue.costBasis) * 100
    };
};

export const getHoldingPerformance = async (
    userId: string,
    holdingId: string
): Promise<HoldingPerformance> => {
    const holdingRepo = getHoldingRepository();
    const holding = await holdingRepo.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    // Verify ownership through portfolio
    const portfolioRepo = getPortfolioRepository();
    const portfolio = await portfolioRepo.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Get stock details
    const stockRepo = getStockRepository();
    const dbStock = await stockRepo.findByISIN(holding.ISIN);
    
    if (!dbStock) {
        throw new Error('Stock not found');
    }

    const holdingWithStock: HoldingWithStock = {
        ...holding,
        stockInfo: {
            symbol: dbStock.SYMBOL.toLowerCase(),
            name: dbStock.NAME,
            isin: dbStock.ISIN
        }
    };

    // Get transactions
    const transactionRepo = getTransactionRepository();
    const transactions = await transactionRepo.findByHolding(holdingId);

    // Calculate performance metrics
    const holdingValue = await calculateHoldingValue(holdingWithStock);

    return {
        totalInvested: holdingValue.costBasis,
        currentValue: holdingValue.currentValue,
        totalReturn: holdingValue.unrealizedGainLoss,
        totalReturnPercentage: (holdingValue.unrealizedGainLoss / holdingValue.costBasis) * 100,
        transactions: transactions.map(t => ({
            ...t,
            PRICE: Number(t.PRICE),
            COMMISSION: Number(t.COMMISSION)
        }))
    };
};

export const updateHolding = async (
    userId: string,
    holdingId: string,
    updateHoldingDTO: UpdateHoldingDTO
): Promise<HoldingDetails> => {
    const holdingRepo = getHoldingRepository();
    const holding = await holdingRepo.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    // Verify ownership through portfolio
    const portfolioRepo = getPortfolioRepository();
    const portfolio = await portfolioRepo.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Update holding
    const updatedHolding = await holdingRepo.update(holdingId, updateHoldingDTO);

    // Get stock details
    const stockRepo = getStockRepository();
    const dbStock = await stockRepo.findByISIN(updatedHolding.ISIN);
    
    if (!dbStock) {
        throw new Error('Stock not found');
    }

    const holdingWithStock: HoldingWithStock = {
        ...updatedHolding,
        stockInfo: {
            symbol: dbStock.SYMBOL.toLowerCase(),
            name: dbStock.NAME,
            isin: dbStock.ISIN
        }
    };

    // Get current price and calculate values
    const quote = await quoteService.getRealTimeQuote(dbStock.ISIN);
    const holdingValue = await calculateHoldingValue(holdingWithStock);

    return {
        ...updatedHolding,
        stock: {
            symbol: dbStock.SYMBOL.toLowerCase(),
            name: dbStock.NAME,
            currency: 'USD' // Default currency since it's not in DB model
        },
        currentPrice: quote.price,
        totalValue: holdingValue.currentValue,
        gainLoss: holdingValue.unrealizedGainLoss,
        gainLossPercentage: (holdingValue.unrealizedGainLoss / holdingValue.costBasis) * 100
    };
};

export const getHoldingHistory = async (
    userId: string,
    holdingId: string
): Promise<HoldingHistory[]> => {
    const holdingRepo = getHoldingRepository();
    const holding = await holdingRepo.findById(holdingId);
    
    if (!holding) {
        throw new Error('Holding not found');
    }

    // Verify ownership through portfolio
    const portfolioRepo = getPortfolioRepository();
    const portfolio = await portfolioRepo.findById(holding.PORTFOLIOS_ID);
    
    if (!portfolio || portfolio.USERS_ID !== userId) {
        throw new Error('Unauthorized');
    }

    // Get transactions
    const transactionRepo = getTransactionRepository();
    const transactions = await transactionRepo.findByHolding(holdingId);

    return transactions.map(t => ({
        date: t.TRANSACTION_TIME,
        buy: t.BUY,
        amount: t.AMOUNT,
        price: Number(t.PRICE),
        value: Number(t.PRICE) * t.AMOUNT,
        commission: Number(t.COMMISSION),
        broker: t.BROKER
    }));
};
