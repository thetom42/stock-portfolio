import { Holding, CreateHoldingDTO, UpdateHoldingDTO, HoldingDetails, Transaction, HoldingPerformance, HoldingValue, HoldingHistory } from '../models/Holding';
import { getHoldingRepository, getPortfolioRepository, getTransactionRepository } from '../utils/database';

export const createHolding = async (
  userId: string,
  holdingData: CreateHoldingDTO
): Promise<Holding> => {
  // First verify the portfolio belongs to the user
  const portfolioRepo = getPortfolioRepository();
  const portfolio = await portfolioRepo.findById(holdingData.PORTFOLIOS_ID);
  
  if (!portfolio || portfolio.USERS_ID !== userId) {
    throw new Error('Portfolio not found or unauthorized');
  }

  // Create the holding
  const holdingRepo = getHoldingRepository();
  const holding = await holdingRepo.create({
    HOLDINGS_ID: '', // Will be generated by the repository
    PORTFOLIOS_ID: holdingData.PORTFOLIOS_ID,
    ISIN: holdingData.ISIN,
    QUANTITY: holdingData.QUANTITY,
    START_DATE: new Date(),
    END_DATE: null
  });

  // Record the initial transaction
  const transactionRepo = getTransactionRepository();
  await transactionRepo.create({
    TRANSACTIONS_ID: '', // Will be generated by the repository
    HOLDINGS_ID: holding.HOLDINGS_ID,
    BUY: true,
    TRANSACTION_TIME: new Date(),
    AMOUNT: holdingData.QUANTITY,
    PRICE: holdingData.PRICE,
    COMMISSION: 0,
    BROKER: 'SYSTEM'
  });

  return holding;
};

export const getHoldingById = async (
  holdingId: string,
  userId: string
): Promise<HoldingDetails | null> => {
  const holdingRepo = getHoldingRepository();
  const holding = await holdingRepo.findById(holdingId);
  
  if (!holding) {
    return null;
  }

  // Verify ownership through portfolio
  const portfolioRepo = getPortfolioRepository();
  const portfolio = await portfolioRepo.findById(holding.PORTFOLIOS_ID);
  
  if (!portfolio || portfolio.USERS_ID !== userId) {
    return null;
  }

  // Get stock details and latest quote
  // Note: In a real implementation, we would fetch this from StockRepository and QuoteRepository
  const holdingDetails: HoldingDetails = {
    ...holding,
    stock: {
      symbol: 'PLACEHOLDER',
      name: 'PLACEHOLDER',
      currency: 'USD'
    },
    currentPrice: 0,
    totalValue: 0,
    gainLoss: 0,
    gainLossPercentage: 0
  };

  return holdingDetails;
};

export const updateHolding = async (
  holdingId: string,
  userId: string,
  updateData: UpdateHoldingDTO
): Promise<Holding | null> => {
  // First verify ownership
  const holding = await getHoldingById(holdingId, userId);
  if (!holding) {
    return null;
  }

  const holdingRepo = getHoldingRepository();
  return holdingRepo.update(holdingId, {
    QUANTITY: updateData.QUANTITY
  });
};

export const deleteHolding = async (
  holdingId: string,
  userId: string
): Promise<void> => {
  // First verify ownership
  const holding = await getHoldingById(holdingId, userId);
  if (!holding) {
    throw new Error('Holding not found or unauthorized');
  }

  const holdingRepo = getHoldingRepository();
  await holdingRepo.delete(holdingId);
};

export const getHoldingPerformance = async (
  holdingId: string,
  userId: string
): Promise<HoldingPerformance | null> => {
  // First verify ownership
  const holding = await getHoldingById(holdingId, userId);
  if (!holding) {
    return null;
  }

  // Get all transactions for this holding
  const transactionRepo = getTransactionRepository();
  const transactions = await transactionRepo.findByHolding(holdingId);

  // Calculate performance metrics
  const totalInvested = transactions.reduce((sum, t) => {
    return t.BUY ? sum + (t.AMOUNT * Number(t.PRICE)) : sum - (t.AMOUNT * Number(t.PRICE));
  }, 0);

  return {
    totalInvested,
    currentValue: 0, // Would be calculated using latest quote
    totalReturn: 0,
    totalReturnPercentage: 0,
    transactions: transactions as Transaction[]
  };
};

export const getHoldingTransactions = async (
  holdingId: string,
  userId: string
): Promise<Transaction[] | null> => {
  // First verify ownership
  const holding = await getHoldingById(holdingId, userId);
  if (!holding) {
    return null;
  }

  const transactionRepo = getTransactionRepository();
  const transactions = await transactionRepo.findByHolding(holdingId);
  return transactions as Transaction[];
};

export const getHoldingValue = async (
  holdingId: string,
  userId: string
): Promise<HoldingValue | null> => {
  // First verify ownership
  const holding = await getHoldingById(holdingId, userId);
  if (!holding) {
    return null;
  }

  // Get latest transaction for cost basis
  const transactionRepo = getTransactionRepository();
  const transactions = await transactionRepo.findByHolding(holdingId);
  
  const costBasis = transactions.reduce((sum, t) => {
    return t.BUY ? sum + (t.AMOUNT * Number(t.PRICE)) : sum - (t.AMOUNT * Number(t.PRICE));
  }, 0);

  return {
    quantity: holding.QUANTITY,
    costBasis,
    averageCost: costBasis / holding.QUANTITY,
    currentValue: 0, // Would be calculated using latest quote
    unrealizedGainLoss: 0 // Would be calculated using latest quote
  };
};

export const getHoldingHistory = async (
  holdingId: string,
  userId: string
): Promise<HoldingHistory[] | null> => {
  // First verify ownership
  const holding = await getHoldingById(holdingId, userId);
  if (!holding) {
    return null;
  }

  const transactionRepo = getTransactionRepository();
  const transactions = await transactionRepo.findByHolding(holdingId);

  return transactions.map(t => ({
    date: t.TRANSACTION_TIME,
    buy: t.BUY,
    amount: t.AMOUNT,
    price: Number(t.PRICE),
    value: t.AMOUNT * Number(t.PRICE),
    commission: Number(t.COMMISSION),
    broker: t.BROKER
  }));
};
